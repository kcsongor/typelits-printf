-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe printf from parsing GHC TypeLits Symbol
--   
--   An extensible and type-safe printf from parsing GHC TypeLits Symbol
--   literals, matching the semantics of <a>P.printf</a> from
--   <a>Text.Printf</a> in <i>base</i>. The difference is that the variants
--   here will always fail to compile if given arguments of the wrong type
--   (or too many or too little arguments). Most of the variants also
--   provide useful type feedback, telling you the type of arguments it
--   expects and how many when queried with <tt>:t</tt> or with typed
--   holes.
--   
--   See README and documentation of <a>GHC.TypeLits.Printf</a> for more
--   information
@package typelits-printf
@version 0.1.0.0


-- | Internal workings of the printf mechanisms, exposed for potential
--   debugging purposes.
--   
--   Please do not use this module for anything besides debugging, as is
--   definitely very unstable and might go away or change dramatically
--   between versions.
module GHC.TypeLits.Printf.Internal
type ParseFmtStr str = EvalParser FmtStrParser str
type ParseFmtStr_ str = EvalParser_ FmtStrParser str
type ParseFmt str = EvalParser FFParser str
type ParseFmt_ str = EvalParser_ FFParser str

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment
type family ShowFormat (x :: k) :: Symbol

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign
data WidthMod
WMhh :: WidthMod
WMh :: WidthMod
WMl :: WidthMod
WMll :: WidthMod
WML :: WidthMod
data Flags
Flags :: Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> Flags
[fAdjust] :: Flags -> Maybe FormatAdjustment
[fSign] :: Flags -> Maybe FormatSign
[fAlternate] :: Flags -> Bool
type EmptyFlags = 'Flags 'Nothing 'Nothing 'False
data FieldFormat
FF :: Flags -> Maybe Nat -> Maybe Nat -> Maybe WidthMod -> SChar -> FieldFormat
[fmtFlags] :: FieldFormat -> Flags
[fmtWidth] :: FieldFormat -> Maybe Nat
[fmtPrecision] :: FieldFormat -> Maybe Nat
[fmtWidthMod] :: FieldFormat -> Maybe WidthMod
[fmtChar] :: FieldFormat -> SChar

-- | A type synonym for a single-character symbol. Ideally this would just
--   be <a>Char</a>, but we don't have chars at the type level. So, if you
--   see <a>SChar</a> in a type signature, it means that it's expected to
--   be a symbol/string with only one single character.
type SChar = Symbol
type family Demote k = a | a -> k
class Reflect (x :: a)
reflect :: Reflect x => p x -> Demote a

-- | Typeclass associating format types (<tt>d</tt>, <tt>f</tt>, etc.) with
--   the types that can be formatted by them.
--   
--   You can extend the printf methods here for your own types by writing
--   your instances here.
class FormatType (t :: SChar) a
formatArg :: FormatType t a => p t -> a -> FieldFormat -> ShowS
formatArg :: (FormatType t a, PrintfArg a) => p t -> a -> FieldFormat -> ShowS

-- | Required wrapper around inputs to <a>pprintf</a> (guarded polyarity).
--   See documentation for <a>pprintf</a> for examples of usage.
--   
--   You can "wrap" any value in <a>PP</a> as long as it can be formatted
--   as the format type indicated.
--   
--   For example, to make a <tt><a>PP</a> "f"</tt>, you can use
--   <tt><a>PP</a> 3.5</tt> or <tt><a>PP</a> 94.2</tt>, but not
--   <tt><a>PP</a> (3 :: Int)</tt> or <tt><a>PP</a> "hello"</tt>. To make a
--   value of type <tt><a>PP</a> c</tt>, you must wrap a value that can be
--   formatted via <tt>c</tt>.
data PP (c :: SChar)
PP :: a -> PP (c :: SChar)
class RPrintf (str :: Symbol) ps

-- | A version of <a>rprintf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf_ (Proxy :: Proxy "You have %.2f dollars, %s")
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
rprintf_ :: RPrintf str ps => p str -> FormatArgs ps -> String

-- | A heterogeneous list (from <a>Data.Vinyl.Core</a>) used for calling
--   with <a>rprintf</a>. Instead of supplying the inputs as different
--   arguments, we can gather all the inputs into a single list to give to
--   <a>rprintf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s"
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
--   
--   To construct a <tt><a>FormatArgs</a> '["f", "s"]</tt>, you need to
--   give a value formattable by <tt>f</tt> and a value formattable by
--   <tt>s</tt>, given like a linked list, with <a>:%</a> for cons and
--   <a>RNil</a> for nil.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 :% "Luigi" :% RNil)
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   (This should evoke the idea of of <tt>3.62 : <a>Luigi</a> : []</tt>,
--   even though the latter is not possible in Haskell)
type FormatArgs = Rec PP
class RFormat (ffs :: [Either Symbol FieldFormat]) (ps :: [SChar]) | ffs -> ps
rformat :: RFormat ffs ps => p ffs -> FormatArgs ps -> ShowS
class Printf (str :: Symbol) fun

-- | A version of <a>printf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ printf_ (Proxy :: Proxy "You have %.2f dollars, %s") 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
printf_ :: Printf str fun => p str -> fun

-- | The typeclass supporting polyarity used by <a>printf</a>. It works in
--   mostly the same way as <a>PrintfType</a> from <a>Text.Printf</a>, and
--   similar the same as <a>FormatF</a>.
--   
--   Ideally, you will never have to run into this typeclass or have to
--   deal with it. It will come up if you ask for the type of
--   <a>printf</a>, or sometimes if you give the wrong number or type of
--   arguments to it.
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s"
--   FormatFun '[ Right ..., 'Left " dollars ", 'Right ...] fun =&gt; fun
--   </pre>
--   
--   Every item in the first argument of <a>FormatFun</a> is a chunk of the
--   formatting string, split between format holes (<a>Right</a>) and
--   string chunks (<a>Left</a>). You can successively "eliminate" them by
--   providing more arguments that implement each hole:
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62
--   FormatFun '[ Right ...] fun =&gt; fun
--   </pre>
--   
--   Until you you finally fill all the holes:
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatFun '[] t =&gt; t
--   </pre>
--   
--   at which point you may use it as a <a>String</a> or <tt><a>IO</a>
--   ()</tt>, in the same way that <a>Text.Printf</a> works. We also
--   support using strict <a>Text</a> lazy <a>Text</a> as well.
--   
--   So, while it's possible to reason with this using the types, it's
--   usually more difficult than with <tt>pprintf</tt> and
--   <tt>rprintf</tt>.
--   
--   This is why, instead of reasoning with this using its types, it's
--   easier to reason with it using the errors instead:
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s"
--   -- ERROR: Call to printf missing argument fulfilling "%.2f"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi" 72
--   -- ERROR: An extra argument of type Integer was given to a call to printf
--   -- Either remove the argument, or rewrite the format string to include the
--   -- appropriate hole.
--   </pre>
--   
--   If you're having problems getting the error messages to give helpful
--   feedback, try using <a>pHelp</a>:
--   
--   <pre>
--   &gt;&gt;&gt; pHelp $ printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <a>pHelp</a> can give the type system the nudge it needs to provide
--   good errors.
class FormatFun (ffs :: [Either Symbol FieldFormat]) fun
formatFun :: FormatFun ffs fun => p ffs -> String -> fun

-- | Utility type powering <a>pfmt</a>. See dcumentation for <a>pfmt</a>
--   for more information on usage.
--   
--   Using <i>OverloadedLabels</i>, you never need to construct this
--   directly can just write <tt>#f</tt> and a <tt><a>PFmt</a> "f"</tt>
--   will be generated. You can also create this using <a>mkPFmt</a> or
--   <a>mkPFmt_</a>, in the situations where <i>OverloadedLabels</i>
--   doesn't work or is not wanted.
newtype PFmt c
PFmt :: FieldFormat -> PFmt c

-- | Parse and run a <i>single</i> format hole on a single vale. Can be
--   useful for formatting individual items or for testing your own custom
--   instances of <a>FormatType</a>.
--   
--   Usually meant to be used with <i>OverloadedLabels</i>:
--   
--   <pre>
--   &gt;&gt;&gt; pfmt #f 3.62
--   "3.62"
--   </pre>
--   
--   However, current versions of GHC disallow labels that aren't valid
--   identifier names, disallowing things like <tt><a>pfmt</a> #.2f
--   3.62</tt>. While there is an
--   &lt;<a>https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0170-unrestricted-overloadedlabels.rst</a>
--   approved proposal&gt; that allows this, if you are using an earlier
--   GHC version, you can get around this using <a>mkPFmt</a>:
--   
--   <pre>
--   &gt;&gt;&gt; pfmt (mkPFmt @".2f") 3.6234124
--   "3.62"
--   </pre>
--   
--   Ideally we'd want to be able to write
--   
--   <pre>
--   &gt;&gt;&gt; pfmt #.2f 3.6234124
--   "3.62"
--   </pre>
--   
--   (which should be possible in GHC 8.10+)
--   
--   Note that the format string does not include the leading <tt>%</tt>.
pfmt :: forall c a. FormatType c a => PFmt c -> a -> String

-- | Useful for using <a>pfmt</a> without <i>OverloadedLabels</i>, or also
--   when passing format specifiers that aren't currently allowed with
--   <i>OverloadedLabels</i> until GHC 8.10+ (like <tt>#.2f</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; pfmt (mkPFmt @".2f") 3.6234124
--   "3.62"
--   </pre>
mkPFmt :: forall str lst ff f w q m c. (Listify str lst, ff ~ ParseFmt_ lst, Reflect ff, ff ~ 'FF f w q m c) => PFmt c

-- | A version of <a>mkPFmt</a> that takes an explicit proxy input.
--   
--   <pre>
--   &gt;&gt;&gt; pfmt (mkPFmt_ (Proxy :: Proxy ".2f") 3.6234124
--   "3.62"
--   </pre>
mkPFmt_ :: forall str lst ff f w q m c p. (Listify str lst, ff ~ ParseFmt_ lst, Reflect ff, ff ~ 'FF f w q m c) => p str -> PFmt c

-- | A useful token for helping the type system give useful errors for
--   <tt>printf</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have ".2f" dollars, %s" 3.26 :: PHelp
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   Usually things should work out on their own without needing this ...
--   but sometimes the type system could need a nudge.
--   
--   See also <a>pHelp</a>
newtype PHelp
PHelp :: String -> PHelp

-- | A useful helper function for helping the type system give useful
--   errors for <tt>printf</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; pHelp $ printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   Usually things would work out on their own without needing this ...
--   but sometimes the type system could need a nudge.
[pHelp] :: PHelp -> String
instance (Data.Symbol.Utils.Listify str lst, ff GHC.Types.~ GHC.TypeLits.Printf.Parse.ParseFmt_ lst, GHC.TypeLits.Printf.Parse.Reflect ff, ff GHC.Types.~ 'GHC.TypeLits.Printf.Parse.FF f w p m c) => GHC.OverloadedLabels.IsLabel str (GHC.TypeLits.Printf.Internal.PFmt c)
instance (Data.Symbol.Utils.Listify str lst, ffs GHC.Types.~ GHC.TypeLits.Printf.Parse.ParseFmtStr_ lst, GHC.TypeLits.Printf.Internal.FormatFun ffs fun) => GHC.TypeLits.Printf.Internal.Printf str fun
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) GHC.Base.String
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) ()
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) Data.Text.Internal.Text
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) Data.Text.Internal.Lazy.Text
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) GHC.TypeLits.Printf.Internal.PHelp
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) (GHC.Types.IO a)
instance (a GHC.Types.~ GHC.Types.Char) => GHC.TypeLits.Printf.Internal.FormatFun '[] GHC.TypeLits.Printf.Internal.PHelp
instance (a GHC.Types.~ GHC.Types.Char) => GHC.TypeLits.Printf.Internal.FormatFun '[] [a]
instance (a GHC.Types.~ GHC.Types.Char) => GHC.TypeLits.Printf.Internal.FormatFun '[] Data.Text.Internal.Text
instance (a GHC.Types.~ GHC.Types.Char) => GHC.TypeLits.Printf.Internal.FormatFun '[] Data.Text.Internal.Lazy.Text
instance (a GHC.Types.~ ()) => GHC.TypeLits.Printf.Internal.FormatFun '[] (GHC.Types.IO a)
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun '[] ()
instance (TypeError ...) => GHC.TypeLits.Printf.Internal.FormatFun '[] (a -> b)
instance (GHC.TypeLits.KnownSymbol str, GHC.TypeLits.Printf.Internal.FormatFun ffs fun) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Left str : ffs) fun
instance (GHC.TypeLits.Printf.Parse.Reflect ff, ff GHC.Types.~ 'GHC.TypeLits.Printf.Parse.FF f w p m c, GHC.TypeLits.Printf.Internal.FormatType c a, GHC.TypeLits.Printf.Internal.FormatFun ffs fun) => GHC.TypeLits.Printf.Internal.FormatFun ('Data.Either.Right ff : ffs) (a -> fun)
instance (Data.Symbol.Utils.Listify str lst, ffs GHC.Types.~ GHC.TypeLits.Printf.Parse.ParseFmtStr_ lst, GHC.TypeLits.Printf.Internal.RFormat ffs ps) => GHC.TypeLits.Printf.Internal.RPrintf str ps
instance GHC.TypeLits.Printf.Internal.RFormat '[] '[]
instance (GHC.TypeLits.KnownSymbol str, GHC.TypeLits.Printf.Internal.RFormat ffs ps) => GHC.TypeLits.Printf.Internal.RFormat ('Data.Either.Left str : ffs) ps
instance (GHC.TypeLits.Printf.Parse.Reflect ff, ff GHC.Types.~ 'GHC.TypeLits.Printf.Parse.FF f w p m c, GHC.TypeLits.Printf.Internal.RFormat ffs ps) => GHC.TypeLits.Printf.Internal.RFormat ('Data.Either.Right ff : ffs) (c : ps)
instance GHC.TypeLits.Printf.Internal.FormatType "c" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "c" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "c" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "d" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "o" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "x" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "X" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "b" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "u" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "f" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "f" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "F" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "F" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "g" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "g" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "G" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "G" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "e" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "e" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "E" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "E" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "s" GHC.Base.String
instance GHC.TypeLits.Printf.Internal.FormatType "s" Data.Text.Internal.Text
instance GHC.TypeLits.Printf.Internal.FormatType "s" Data.Text.Internal.Lazy.Text
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Types.Char
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Types.Int
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Int.Int8
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Int.Int16
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Int.Int32
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Int.Int64
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Natural.Natural
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Types.Word
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Word.Word8
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Word.Word16
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Word.Word32
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Word.Word64
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Types.Double
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Types.Float
instance GHC.TypeLits.Printf.Internal.FormatType "v" GHC.Base.String
instance GHC.TypeLits.Printf.Internal.FormatType "v" Data.Text.Internal.Text
instance GHC.TypeLits.Printf.Internal.FormatType "v" Data.Text.Internal.Lazy.Text


-- | An extensible and type-safe printf from parsing GHC TypeLits Symbol
--   literals, matching the semantics of <a>printf</a> from
--   <a>Text.Printf</a> in <i>base</i>. The difference is that the variants
--   here will always fail to compile if given arguments of the wrong type
--   (or too many or too little arguments). Most of the variants also
--   provide useful type feedback, telling you the type of arguments it
--   expects and how many when queried with <tt>:t</tt> or with typed
--   holes. See documentation in <a>Text.Printf</a> for details on how this
--   formats items of various types, and the differences with C
--   <tt>printf(3)</tt>.
--   
--   Comparing their usage/calling conventions:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ pprintf @"You have %.2f dollars, %s" (PP 3.62) (PP "Luigi")
--   You have 3.62 dollars, Luigi
--   
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 :% "Luigi" :% RNil)
--   You have 3.62 dollars, Luigi
--   
--   &gt;&gt;&gt; putStrLn $ printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   Now comparing their types:
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   PP "f" -&gt; PP "s" -&gt; String
--   
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatArgs '["f", "s"] -&gt; String
--   
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatFun '[ .... ] fun =&gt; fun
--   </pre>
--   
--   <ul>
--   <li>For <a>pprintf</a>, it shows you need two arguments: A
--   <tt><a>PP</a> "f"</tt> (which is a value that supports being formatted
--   by <tt>f</tt>) like <tt>PP 3.62</tt>, and a <tt><a>PP</a> "s"</tt>,
--   like <tt>PP <a>Luigi</a></tt>.</li>
--   <li><a>rprintf</a> tells you you need a two-item hlist (from
--   <a>Data.Vinyl.Core</a>), where the first item implements <tt>f</tt>
--   and the second item implements <tt>s</tt>: <tt>3.62 <a>:%</a>
--   <a>Luigi</a> :% <a>RNil</a></tt> will do.</li>
--   <li>The type of <a>printf</a> is much less informative. It's possible
--   to see what you need from the <tt>...</tt> in <a>FormatFun</a>...but
--   it's basically a situation that works fine when it does, but can be
--   tricky if you mess up. The up-side is that it is the cleanest to call
--   if you already know what you need: you can just give the arguments
--   plainly, like <tt>3.62</tt> and <tt><a>Luigi</a></tt>.</li>
--   <li>The type of <a>printf</a> doesn't tell you immediately what you
--   you need. However, if you do try to use it, the type errors will guide
--   you along the way, iteratively.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s"
--   -- ERROR: Call to printf missing argument fulfilling "%.2f"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi" 72
--   -- ERROR: An extra argument of type Integer was given to a call to printf
--   -- Either remove the argument, or rewrite the format string to include the
--   -- appropriate hole.
--   </pre>
--   
--   The following table summarizes the features and drawbacks of each
--   method:
--   
--   TODO: table
--   
--   <i>Ideally</i> we would have a solution that has all three. However,
--   as of now, we have a "pick two" sort of situation. Suggestions are
--   definitely welcome, however, if you find something that satisfies all
--   three benefits while still allowing for polymorphism!
--   
--   You can extend functionality with formatting for your own types by
--   providing instances of <tt>FormatType</tt>.
--   
--   Also in this module is <a>pfmt</a>, which allows you to format
--   individual items according to a single format specifier.
module GHC.TypeLits.Printf

-- | Typeclass associating format types (<tt>d</tt>, <tt>f</tt>, etc.) with
--   the types that can be formatted by them.
--   
--   You can extend the printf methods here for your own types by writing
--   your instances here.
class FormatType (t :: SChar) a
formatArg :: FormatType t a => p t -> a -> FieldFormat -> ShowS
formatArg :: (FormatType t a, PrintfArg a) => p t -> a -> FieldFormat -> ShowS

-- | A type synonym for a single-character symbol. Ideally this would just
--   be <a>Char</a>, but we don't have chars at the type level. So, if you
--   see <a>SChar</a> in a type signature, it means that it's expected to
--   be a symbol/string with only one single character.
type SChar = Symbol

-- | Type-safe printf with true guarded polyarity. Call it like
--   <tt><a>pprintf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   A call to printf on a valid string will <i>always</i> give a
--   well-defined type for a function in return:
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf @"You have %.2f dollars, %s"
--   PP "f" -&gt; PP "s" -&gt; String
--   </pre>
--   
--   You can always query the type, and get a well-defined type back, which
--   you can utilize using typed holes or other type-guided development
--   techniques.
--   
--   To give <a>pprintf</a> its arguments, however, they must be wrapped in
--   <a>PP</a>:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ pprintf @"You have %.2f dollars, %s" (PP 3.62) (PP "Luigi")
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   See <a>printf</a> for a polyariadic method that doesn't require
--   <a>PP</a> on its inputs, but with a less helpful type signature, and
--   <a>rprintf</a> for a fake-polyariadic method that doesn't require
--   <a>PP</a>, but requires arguments in a single list instead. Also see
--   top-level module documentation <a>GHC.TypeLits.Printf</a> for a more
--   comprehensive summary.
pprintf :: forall str ps. (RPrintf str ps, RecordCurry ps) => CurriedF PP ps String

-- | A version of <a>pprintf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf_ (Proxy :: Proxy "You have %.2f dollars, %s")
--   PP "f" -&gt; PP "s" -&gt; String
--   </pre>
pprintf_ :: forall str ps p. (RPrintf str ps, RecordCurry ps) => p str -> CurriedF PP ps String

-- | Required wrapper around inputs to <a>pprintf</a> (guarded polyarity).
--   See documentation for <a>pprintf</a> for examples of usage.
--   
--   You can "wrap" any value in <a>PP</a> as long as it can be formatted
--   as the format type indicated.
--   
--   For example, to make a <tt><a>PP</a> "f"</tt>, you can use
--   <tt><a>PP</a> 3.5</tt> or <tt><a>PP</a> 94.2</tt>, but not
--   <tt><a>PP</a> (3 :: Int)</tt> or <tt><a>PP</a> "hello"</tt>. To make a
--   value of type <tt><a>PP</a> c</tt>, you must wrap a value that can be
--   formatted via <tt>c</tt>.
data PP (c :: SChar)
PP :: a -> PP (c :: SChar)

-- | Type-safe printf with faked polyarity. Pass in a "list" of arguments
--   (using <a>:%</a> and <a>RNil</a>), instead of as multiple arguments.
--   Call it like <tt><a>rprintf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s"
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
--   
--   This means that it is expecting something that can be printed with
--   <tt>f</tt> and something that can be printed with <tt>s</tt>. We can
--   provide a <a>Double</a> and a <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 ':%' "Luigi" :% 'RNil')
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   See <a>pprintf</a> for a version with true polyarity and good clear
--   types, but requires wrapping its arguments, and <a>printf</a> for a
--   version with true polyarity but less clear types. Also see top-level
--   module documentation <a>GHC.TypeLits.Printf</a> for a more
--   comprehensive summary.
rprintf :: forall str ps. RPrintf str ps => FormatArgs ps -> String

-- | A version of <a>rprintf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf_ (Proxy :: Proxy "You have %.2f dollars, %s")
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
rprintf_ :: RPrintf str ps => p str -> FormatArgs ps -> String

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u])
[RNil] :: forall u (a :: u -> Type). Rec a ('[] :: [u])

-- | Pattern and constructor allowing you to construct a <a>FormatArgs</a>.
--   
--   To construct a <tt><a>FormatArgs</a> '["f", "s"]</tt>, for instance,
--   you need to give a value formattable by <tt>f</tt> and a value
--   formattable by <tt>s</tt>, given like a linked list, with <a>:%</a>
--   for cons and <a>RNil</a> for nil.
--   
--   <pre>
--   3.62 <a>:%</a> <a>Luigi</a> :% <a>RNil</a>
--   </pre>
--   
--   (This should evoke the idea of of <tt>3.62 : <a>Luigi</a> : []</tt>,
--   even though the latter is not possible in Haskell)
pattern (:%) :: () => FormatType c a => a -> FormatArgs cs -> FormatArgs (c : cs)
infixr 7 :%

-- | A heterogeneous list (from <a>Data.Vinyl.Core</a>) used for calling
--   with <a>rprintf</a>. Instead of supplying the inputs as different
--   arguments, we can gather all the inputs into a single list to give to
--   <a>rprintf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s"
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
--   
--   To construct a <tt><a>FormatArgs</a> '["f", "s"]</tt>, you need to
--   give a value formattable by <tt>f</tt> and a value formattable by
--   <tt>s</tt>, given like a linked list, with <a>:%</a> for cons and
--   <a>RNil</a> for nil.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 :% "Luigi" :% RNil)
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   (This should evoke the idea of of <tt>3.62 : <a>Luigi</a> : []</tt>,
--   even though the latter is not possible in Haskell)
type FormatArgs = Rec PP

-- | Type-safe printf with true naked polyarity. Call it like
--   <tt><a>printf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   While the type of <tt><a>printf</a> @"my fmt string"</tt> isn't going
--   to be very helpful, the error messages should help guide you along the
--   way:
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s"
--   -- ERROR: Call to printf missing argument fulfilling "%.2f"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi" 72
--   -- ERROR: An extra argument of type Integer was given to a call to printf
--   -- Either remove the argument, or rewrite the format string to include the
--   -- appropriate hole.
--   </pre>
--   
--   If you're having problems getting the error messages to give helpful
--   feedback, try using <a>pHelp</a>:
--   
--   <pre>
--   &gt;&gt;&gt; pHelp $ printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <a>pHelp</a> can give the type system the nudge it needs to provide
--   good errors.
--   
--   See <a>pprintf</a> for a version of this with nicer types and type
--   errors, but requires wrapping arguments, and <a>rprintf</a> for a
--   version of this with "fake" polyarity, taking a list as input instead.
--   Also see top-level module documentation <a>GHC.TypeLits.Printf</a> for
--   a more comprehensive summary.
--   
--   Note that this also supports the "interpret as an IO action to print
--   out results" functionality that <a>Text.Printf</a> supports. This also
--   supports returning strict <a>Text</a> and lazy <a>Text</a> as well.
printf :: forall str fun. Printf str fun => fun

-- | A version of <a>printf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ printf_ (Proxy :: Proxy "You have %.2f dollars, %s") 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
printf_ :: Printf str fun => p str -> fun

-- | A useful token for helping the type system give useful errors for
--   <tt>printf</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have ".2f" dollars, %s" 3.26 :: PHelp
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   Usually things should work out on their own without needing this ...
--   but sometimes the type system could need a nudge.
--   
--   See also <a>pHelp</a>
data PHelp

-- | A useful helper function for helping the type system give useful
--   errors for <tt>printf</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; pHelp $ printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   Usually things would work out on their own without needing this ...
--   but sometimes the type system could need a nudge.
pHelp :: PHelp -> String

-- | The typeclass supporting polyarity used by <a>printf</a>. It works in
--   mostly the same way as <a>PrintfType</a> from <a>Text.Printf</a>, and
--   similar the same as <a>FormatF</a>.
--   
--   Ideally, you will never have to run into this typeclass or have to
--   deal with it. It will come up if you ask for the type of
--   <a>printf</a>, or sometimes if you give the wrong number or type of
--   arguments to it.
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s"
--   FormatFun '[ Right ..., 'Left " dollars ", 'Right ...] fun =&gt; fun
--   </pre>
--   
--   Every item in the first argument of <a>FormatFun</a> is a chunk of the
--   formatting string, split between format holes (<a>Right</a>) and
--   string chunks (<a>Left</a>). You can successively "eliminate" them by
--   providing more arguments that implement each hole:
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62
--   FormatFun '[ Right ...] fun =&gt; fun
--   </pre>
--   
--   Until you you finally fill all the holes:
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatFun '[] t =&gt; t
--   </pre>
--   
--   at which point you may use it as a <a>String</a> or <tt><a>IO</a>
--   ()</tt>, in the same way that <a>Text.Printf</a> works. We also
--   support using strict <a>Text</a> lazy <a>Text</a> as well.
--   
--   So, while it's possible to reason with this using the types, it's
--   usually more difficult than with <tt>pprintf</tt> and
--   <tt>rprintf</tt>.
--   
--   This is why, instead of reasoning with this using its types, it's
--   easier to reason with it using the errors instead:
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s"
--   -- ERROR: Call to printf missing argument fulfilling "%.2f"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printf @"You have %.2f dollars, %s" 3.62 "Luigi" 72
--   -- ERROR: An extra argument of type Integer was given to a call to printf
--   -- Either remove the argument, or rewrite the format string to include the
--   -- appropriate hole.
--   </pre>
--   
--   If you're having problems getting the error messages to give helpful
--   feedback, try using <a>pHelp</a>:
--   
--   <pre>
--   &gt;&gt;&gt; pHelp $ printf @"You have %.2f dollars, %s" 3.62
--   -- ERROR: Call to printf missing argument fulfilling "%s"
--   -- Either provide an argument or rewrite the format string to not expect
--   -- one.
--   </pre>
--   
--   <a>pHelp</a> can give the type system the nudge it needs to provide
--   good errors.
class FormatFun (ffs :: [Either Symbol FieldFormat]) fun

-- | Parse and run a <i>single</i> format hole on a single vale. Can be
--   useful for formatting individual items or for testing your own custom
--   instances of <a>FormatType</a>.
--   
--   Usually meant to be used with <i>OverloadedLabels</i>:
--   
--   <pre>
--   &gt;&gt;&gt; pfmt #f 3.62
--   "3.62"
--   </pre>
--   
--   However, current versions of GHC disallow labels that aren't valid
--   identifier names, disallowing things like <tt><a>pfmt</a> #.2f
--   3.62</tt>. While there is an
--   &lt;<a>https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0170-unrestricted-overloadedlabels.rst</a>
--   approved proposal&gt; that allows this, if you are using an earlier
--   GHC version, you can get around this using <a>mkPFmt</a>:
--   
--   <pre>
--   &gt;&gt;&gt; pfmt (mkPFmt @".2f") 3.6234124
--   "3.62"
--   </pre>
--   
--   Ideally we'd want to be able to write
--   
--   <pre>
--   &gt;&gt;&gt; pfmt #.2f 3.6234124
--   "3.62"
--   </pre>
--   
--   (which should be possible in GHC 8.10+)
--   
--   Note that the format string does not include the leading <tt>%</tt>.
pfmt :: forall c a. FormatType c a => PFmt c -> a -> String

-- | Utility type powering <a>pfmt</a>. See dcumentation for <a>pfmt</a>
--   for more information on usage.
--   
--   Using <i>OverloadedLabels</i>, you never need to construct this
--   directly can just write <tt>#f</tt> and a <tt><a>PFmt</a> "f"</tt>
--   will be generated. You can also create this using <a>mkPFmt</a> or
--   <a>mkPFmt_</a>, in the situations where <i>OverloadedLabels</i>
--   doesn't work or is not wanted.
data PFmt c

-- | Useful for using <a>pfmt</a> without <i>OverloadedLabels</i>, or also
--   when passing format specifiers that aren't currently allowed with
--   <i>OverloadedLabels</i> until GHC 8.10+ (like <tt>#.2f</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; pfmt (mkPFmt @".2f") 3.6234124
--   "3.62"
--   </pre>
mkPFmt :: forall str lst ff f w q m c. (Listify str lst, ff ~ ParseFmt_ lst, Reflect ff, ff ~ 'FF f w q m c) => PFmt c

-- | A version of <a>mkPFmt</a> that takes an explicit proxy input.
--   
--   <pre>
--   &gt;&gt;&gt; pfmt (mkPFmt_ (Proxy :: Proxy ".2f") 3.6234124
--   "3.62"
--   </pre>
mkPFmt_ :: forall str lst ff f w q m c p. (Listify str lst, ff ~ ParseFmt_ lst, Reflect ff, ff ~ 'FF f w q m c) => p str -> PFmt c
