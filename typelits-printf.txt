-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/typelits-printf#readme</a>
@package typelits-printf
@version 0.1.0.0

module GHC.TypeLits.Printf.Internal.Parser

-- | A type synonym for a single-character symbol
type SChar = Symbol
type Parser a = a -> Type
type family RunParser (p :: Parser a) (str :: [SChar]) :: Maybe (a, [SChar])
data Pure :: a -> Parser a
data Sym :: SChar -> Parser SChar
type family SymHelp (c :: SChar) (str :: [SChar]) :: Maybe (SChar, [SChar])
data NotSym :: SChar -> Parser SChar
type family NotSymHelp (c :: SChar) (str :: [SChar]) :: Maybe (SChar, [SChar])
data AnySym :: Parser SChar
type family AnySymHelp (str :: [SChar]) :: Maybe (SChar, [SChar])
data (<$) :: b -> Parser a -> Parser b
type family RepHelp (x :: b) (r :: Maybe (a, [SChar])) :: Maybe (b, [SChar])
data (<|>) :: Parser a -> Parser a -> Parser a
type family ChoiceMaybe (x :: Maybe a) (y :: Maybe a) :: Maybe a
type Optional p = ('Just <$> p) <|> Pure 'Nothing
data (*>) :: Parser a -> Parser b -> Parser b
type family SeqHelp (p :: Parser b) (r :: Maybe (a, [SChar])) :: Maybe (b, [SChar])

-- | Parse a single digit
data Digit :: Parser Nat
type family DigitHelp (d :: Maybe Nat) (cs :: [SChar]) :: Maybe (Nat, [SChar])
data (<$>) :: (a -> b) -> Parser a -> Parser b
type family MapConHelp (f :: a -> b) (r :: Maybe (a, [SChar])) :: Maybe (b, [SChar])
data (<*>) :: Parser (a -> b) -> Parser a -> Parser b
type family ApHelp (r :: Maybe (a -> b, [SChar])) (q :: Parser a) :: Maybe (b, [SChar])
data Many :: Parser a -> Parser [a]
data Some :: Parser a -> Parser [a]

-- | Parse a number
data Number :: Parser Nat
type family NumberHelp (xs :: Maybe ([Nat], [SChar])) :: Maybe (Nat, [SChar])
data Cat :: Parser [SChar] -> Parser Symbol
type family CatHelp (xs :: Maybe ([SChar], [SChar])) :: Maybe (Symbol, [SChar])
type family EvalHelp (r :: Maybe (a, [SChar])) :: Maybe a
type EvalParser (p :: Parser a) str = EvalHelp (RunParser p str) :: Maybe a
type family EvalHelp_ (r :: Maybe (a, [SChar])) :: a
type EvalParser_ (p :: Parser a) str = EvalHelp_ (RunParser p str) :: a
type family CharDigit (c :: SChar) :: Maybe Nat
type family FromDigits (xs :: [Nat]) (n :: Nat) :: Nat
type family CatChars (cs :: [SChar]) :: Symbol

module GHC.TypeLits.Printf.Parse
type ParseFmtStr str = EvalParser FmtStrParser str
type ParseFmtStr_ str = EvalParser_ FmtStrParser str

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign
data WidthMod
WMhh :: WidthMod
WMh :: WidthMod
WMl :: WidthMod
WMll :: WidthMod
WML :: WidthMod
data Flags
Flags :: Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> Flags
[fAdjust] :: Flags -> Maybe FormatAdjustment
[fSign] :: Flags -> Maybe FormatSign
[fAlternate] :: Flags -> Bool
type EmptyFlags = 'Flags 'Nothing 'Nothing 'False
data FieldFormat
FF :: Flags -> Maybe Nat -> Maybe Nat -> Maybe WidthMod -> SChar -> FieldFormat
[fmtFlags] :: FieldFormat -> Flags
[fmtWidth] :: FieldFormat -> Maybe Nat
[fmtPrecision] :: FieldFormat -> Maybe Nat
[fmtWidthMod] :: FieldFormat -> Maybe WidthMod
[fmtChar] :: FieldFormat -> SChar

-- | A type synonym for a single-character symbol
type SChar = Symbol
type family Demote k = a | a -> k
class Reflect (x :: a)
reflect :: Reflect x => p x -> Demote a
instance GHC.TypeLits.Printf.Parse.Reflect 'Text.Printf.LeftAdjust
instance GHC.TypeLits.Printf.Parse.Reflect 'Text.Printf.ZeroPad
instance GHC.TypeLits.Printf.Parse.Reflect 'Text.Printf.SignPlus
instance GHC.TypeLits.Printf.Parse.Reflect 'Text.Printf.SignSpace
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.TypeLits.Printf.Parse.WMhh
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.TypeLits.Printf.Parse.WMh
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.TypeLits.Printf.Parse.WMl
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.TypeLits.Printf.Parse.WMll
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.TypeLits.Printf.Parse.WML
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.Types.False
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.Types.True
instance GHC.TypeLits.Printf.Parse.Reflect 'GHC.Maybe.Nothing
instance forall a (x :: a). GHC.TypeLits.Printf.Parse.Reflect x => GHC.TypeLits.Printf.Parse.Reflect ('GHC.Maybe.Just x)
instance GHC.TypeNats.KnownNat n => GHC.TypeLits.Printf.Parse.Reflect n
instance GHC.TypeLits.KnownSymbol n => GHC.TypeLits.Printf.Parse.Reflect n
instance (GHC.TypeLits.Printf.Parse.Reflect d, GHC.TypeLits.Printf.Parse.Reflect i, GHC.TypeLits.Printf.Parse.Reflect l) => GHC.TypeLits.Printf.Parse.Reflect ('GHC.TypeLits.Printf.Parse.Flags d i l)
instance (GHC.TypeLits.Printf.Parse.Reflect flags, GHC.TypeLits.Printf.Parse.Reflect width, GHC.TypeLits.Printf.Parse.Reflect prec, GHC.TypeLits.Printf.Parse.Reflect mods, GHC.TypeLits.Printf.Parse.Reflect chr) => GHC.TypeLits.Printf.Parse.Reflect ('GHC.TypeLits.Printf.Parse.FF flags width prec mods chr)


-- | Master table comparing the different methods:
--   
--   TODO: table
module GHC.TypeLits.Printf

-- | Typeclass associating format types (<tt>d</tt>, <tt>f</tt>, etc.) with
--   the types that can be formatted by them.
--   
--   You can extend the printf methods here for your own types by writing
--   your instances here.
class FormatChar (t :: SChar) a
formatArg :: FormatChar t a => p t -> a -> FieldFormat -> ShowS
formatArg :: (FormatChar t a, PrintfArg a) => p t -> a -> FieldFormat -> ShowS

-- | A type synonym for a single-character symbol
type SChar = Symbol

-- | Type-safe printf with true guarded polyarity. Call it like
--   <tt><a>pprintf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   A call to printf on a valid string will <i>always</i> give a
--   well-defined type for a function in return:
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf @"You have %.2f dollars, %s"
--   PP "f" -&gt; PP "s" -&gt; String
--   </pre>
--   
--   You can always query the type, and get a well-defined type back, which
--   you can utilize using typed holes or other type-guided development
--   techniques.
--   
--   To give <a>pprintf</a> its arguments, however, they must be wrapped in
--   <a>PP</a>:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ pprintf @"You have %.2f dollars, %s" (PP 3.62) (PP "Luigi")
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   See <a>printf</a> for a polyariadic method that doesn't require
--   <a>PP</a> on its inputs, but doesn't have as usable a type when
--   queried before supplying its arguments, and <a>rprintf</a> for a
--   fake-polyariadic method that doesn't require <a>PP</a>, but requires
--   arguments in a single list instead.
pprintf :: forall str ps. (RPrintf str ps, RecordCurry ps) => CurriedF PP ps String
pprintf_ :: forall str ps p. (RPrintf str ps, RecordCurry ps) => p str -> CurriedF PP ps String

-- | Required wrapper around inputs to <a>pprintf</a> (guarded polyarity).
--   See documentation for <a>pprintf</a> for examples of usage.
--   
--   You can "wrap" any value in <a>PP</a> as long as it can be formatted
--   as the format type indicated.
--   
--   For example, to make a <tt><a>PP</a> "f"</tt>, you can use
--   <tt><a>PP</a> 3.5</tt> or <tt><a>PP</a> 94.2</tt>, but not
--   <tt><a>PP</a> (3 :: Int)</tt> or <tt><a>PP</a> "hello"</tt>. To make a
--   value of type <tt><a>PP</a> c</tt>, you must wrap a value that can be
--   formatted via <tt>c</tt>.
data PP (c :: SChar)
PP :: a -> PP (c :: SChar)

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u])
[RNil] :: forall u (a :: u -> Type). Rec a ('[] :: [u])
pattern (:%) :: () => FormatChar c a => a -> FormatArgs cs -> FormatArgs (c : cs)
infixr 7 :%
type FormatArgs = Rec PP

-- | Type-safe printf with faked polyarity. Pass in a "list" of arguments
--   (using <a>:%</a> and <a>RNil</a>), instead of as multiple arguments.
--   Call it like <tt><a>rprintf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s"
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
--   
--   This means that it is expecting something that can be printed with
--   <tt>f</tt> and something that can be printed with <tt>s</tt>. We can
--   provide a <a>Double</a> and a <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 ':%' "Luigi" :% 'RNil')
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   See <a>pprintf</a> for a version with true polyarity and good clear
--   types, but requires wrapping its arguments, and <a>printf</a> for a
--   version with true polyarity but less clear types.
rprintf :: forall str ps. RPrintf str ps => FormatArgs ps -> String
rprintf_ :: RPrintf str ps => p str -> FormatArgs ps -> String

-- | Type-safe printf with true naked polyarity. Call it like
--   <tt><a>printf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   If you what the type of this function unapplied (or with not enough
--   arguments), or try to use it with typed holes or type-guided
--   development, the type errors aren't going to be pretty in most
--   situations. In addition, you always have to make sure the result type
--   can be inferred as <a>String</a>, which may require a type annotation
--   in some situations.
--   
--   (Measures have been taken to make the error messages as helpful as
--   possible, but they're not going to be as pretty as for <a>pprintf</a>
--   or <a>rprintf</a>)
--   
--   However, if you use it properly with the right number of arguments,
--   everything should work and be type-safe: code with missing or badly
--   typed arguments will not compile.
--   
--   See <a>pprintf</a> for a version of this with much nicer types and
--   type errors, but requires wrapping arguments, and <a>rprintf</a> for a
--   version of this with "fake" polyarity, taking a list as input instead.
printf :: forall str fun. Printf str fun => fun
printf_ :: Printf str fun => p str -> fun
class FormatFun (ffs :: [Either Symbol FieldFormat]) fun
instance (Data.Symbol.Utils.Listify str lst, 'GHC.Maybe.Just ffs GHC.Types.~ GHC.TypeLits.Printf.Parse.ParseFmtStr lst, GHC.TypeLits.Printf.FormatFun ffs fun) => GHC.TypeLits.Printf.Printf str fun
instance GHC.TypeLits.Printf.FormatFun '[] GHC.Base.String
instance (GHC.TypeLits.KnownSymbol str, GHC.TypeLits.Printf.FormatFun ffs fun) => GHC.TypeLits.Printf.FormatFun ('Data.Either.Left str : ffs) fun
instance (GHC.TypeLits.Printf.Parse.Reflect ff, ff GHC.Types.~ 'GHC.TypeLits.Printf.Parse.FF f w p m c, GHC.TypeLits.Printf.FormatChar c a, GHC.TypeLits.Printf.FormatFun ffs fun) => GHC.TypeLits.Printf.FormatFun ('Data.Either.Right ff : ffs) (a -> fun)
instance (Data.Symbol.Utils.Listify str lst, 'GHC.Maybe.Just ffs GHC.Types.~ GHC.TypeLits.Printf.Parse.ParseFmtStr lst, GHC.TypeLits.Printf.RFormat ffs ps) => GHC.TypeLits.Printf.RPrintf str ps
instance GHC.TypeLits.Printf.RFormat '[] '[]
instance (GHC.TypeLits.KnownSymbol str, GHC.TypeLits.Printf.RFormat ffs ps) => GHC.TypeLits.Printf.RFormat ('Data.Either.Left str : ffs) ps
instance (GHC.TypeLits.Printf.Parse.Reflect ff, ff GHC.Types.~ 'GHC.TypeLits.Printf.Parse.FF f w p m c, GHC.TypeLits.Printf.RFormat ffs ps) => GHC.TypeLits.Printf.RFormat ('Data.Either.Right ff : ffs) (c : ps)
instance GHC.TypeLits.Printf.FormatChar "c" GHC.Types.Char
instance GHC.TypeLits.Printf.FormatChar "c" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "c" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Types.Char
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Types.Int
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Int.Int8
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Int.Int16
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Int.Int32
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Int.Int64
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Natural.Natural
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Types.Word
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Word.Word32
instance GHC.TypeLits.Printf.FormatChar "d" GHC.Word.Word64
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Types.Char
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Types.Int
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Int.Int8
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Int.Int16
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Int.Int32
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Int.Int64
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Natural.Natural
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Types.Word
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Word.Word32
instance GHC.TypeLits.Printf.FormatChar "o" GHC.Word.Word64
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Types.Int
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Int.Int8
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Int.Int16
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Int.Int32
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Int.Int64
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Natural.Natural
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Types.Word
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Word.Word32
instance GHC.TypeLits.Printf.FormatChar "x" GHC.Word.Word64
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Types.Char
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Types.Int
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Int.Int8
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Int.Int16
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Int.Int32
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Int.Int64
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Natural.Natural
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Types.Word
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Word.Word32
instance GHC.TypeLits.Printf.FormatChar "X" GHC.Word.Word64
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Types.Char
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Types.Int
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Int.Int8
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Int.Int16
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Int.Int32
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Int.Int64
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Natural.Natural
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Types.Word
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Word.Word32
instance GHC.TypeLits.Printf.FormatChar "b" GHC.Word.Word64
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Types.Char
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Types.Int
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Int.Int8
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Int.Int16
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Int.Int32
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Int.Int64
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Integer.Type.Integer
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Natural.Natural
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Types.Word
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Word.Word8
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Word.Word16
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Word.Word32
instance GHC.TypeLits.Printf.FormatChar "u" GHC.Word.Word64
instance GHC.TypeLits.Printf.FormatChar "f" GHC.Types.Double
instance GHC.TypeLits.Printf.FormatChar "f" GHC.Types.Float
instance GHC.TypeLits.Printf.FormatChar "F" GHC.Types.Double
instance GHC.TypeLits.Printf.FormatChar "F" GHC.Types.Float
instance GHC.TypeLits.Printf.FormatChar "g" GHC.Types.Double
instance GHC.TypeLits.Printf.FormatChar "g" GHC.Types.Float
instance GHC.TypeLits.Printf.FormatChar "G" GHC.Types.Double
instance GHC.TypeLits.Printf.FormatChar "G" GHC.Types.Float
instance GHC.TypeLits.Printf.FormatChar "e" GHC.Types.Double
instance GHC.TypeLits.Printf.FormatChar "e" GHC.Types.Float
instance GHC.TypeLits.Printf.FormatChar "E" GHC.Types.Double
instance GHC.TypeLits.Printf.FormatChar "E" GHC.Types.Float
instance GHC.TypeLits.Printf.FormatChar "s" GHC.Base.String
instance GHC.TypeLits.Printf.FormatChar "s" Data.Text.Internal.Text
instance GHC.TypeLits.Printf.FormatChar "s" Data.Text.Internal.Lazy.Text
