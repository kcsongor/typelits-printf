-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe printf from parsing GHC TypeLits Symbol
--   
--   An extensible and type-safe printf from parsing GHC TypeLits Symbol
--   literals, matching the semantics of <a>P.printf</a> from
--   <a>Text.Printf</a> in <i>base</i>. The difference is that the variants
--   here will always fail to compile if given arguments of the wrong type
--   (or too many or too little arguments). Most of the variants also
--   provide useful type feedback, telling you the type of arguments it
--   expects and how many when queried with <tt>:t</tt> or with typed
--   holes.
--   
--   See README and documentation of <a>GHC.TypeLits.Printf</a> for more
--   information
@package typelits-printf
@version 0.1.0.0


-- | An extensible and type-safe printf from parsing GHC TypeLits Symbol
--   literals, matching the semantics of <a>printf</a> from
--   <a>Text.Printf</a> in <i>base</i>. The difference is that the variants
--   here will always fail to compile if given arguments of the wrong type
--   (or too many or too little arguments). Most of the variants also
--   provide useful type feedback, telling you the type of arguments it
--   expects and how many when queried with <tt>:t</tt> or with typed
--   holes. See documentation in <a>Text.Printf</a> for details on how this
--   formats items of various types, and the differences with C
--   <tt>printf(3)</tt>.
--   
--   Comparing their usage/calling conventions:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ pprintf @"You have %.2f dollars, %s" (PP 3.62) (PP "Luigi")
--   You have 3.62 dollars, Luigi
--   
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 :% "Luigi" :% RNil)
--   You have 3.62 dollars, Luigi
--   
--   &gt;&gt;&gt; putStrLn $ printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   Now comparing their types:
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   PP "f" -&gt; PP "s" -&gt; String
--   
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatArgs '["f", "s"] -&gt; String
--   
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatFun '[ .... ] fun =&gt; fun
--   </pre>
--   
--   <ul>
--   <li>For <a>pprintf</a>, it shows you need two arguments: A
--   <tt><a>PP</a> "f"</tt> (which is a value that supports being formatted
--   by <tt>f</tt>) like <tt>PP 3.62</tt>, and a <tt><a>PP</a> "s"</tt>,
--   like <tt>PP <a>Luigi</a></tt>.</li>
--   <li><a>rprintf</a> tells you you need a two-item hlist (from
--   <a>Data.Vinyl.Core</a>), where the first item implements <tt>f</tt>
--   and the second item implements <tt>s</tt>: <tt>3.62 <a>:%</a>
--   <a>Luigi</a> :% <a>RNil</a></tt> will do.</li>
--   <li>The type of <a>printf</a> is much less informative. It's possible
--   to see what you need from the <tt>...</tt> in <a>FormatFun</a>...but
--   it's basically a situation that works fine when it does, but can be
--   tricky if you mess up.</li>
--   </ul>
--   
--   The following table summarizes the features and drawbacks of each
--   method:
--   
--   TODO: table
--   
--   <i>Ideally</i> we would have a solution that has all three. However,
--   as of now, we have a "pick two" sort of situation. Suggestions are
--   definitely welcome, however, if you find something that satisfies all
--   three benefits while still allowing for polymorphism!
--   
--   You can extend functionality with formatting for your own types by
--   providing instances of <tt>FormatChar</tt>.
module GHC.TypeLits.Printf

-- | Typeclass associating format types (<tt>d</tt>, <tt>f</tt>, etc.) with
--   the types that can be formatted by them.
--   
--   You can extend the printf methods here for your own types by writing
--   your instances here.
class FormatChar (t :: SChar) a
formatArg :: FormatChar t a => p t -> a -> FieldFormat -> ShowS
formatArg :: (FormatChar t a, PrintfArg a) => p t -> a -> FieldFormat -> ShowS

-- | A type synonym for a single-character symbol
type SChar = Symbol

-- | Type-safe printf with true guarded polyarity. Call it like
--   <tt><a>pprintf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   A call to printf on a valid string will <i>always</i> give a
--   well-defined type for a function in return:
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf @"You have %.2f dollars, %s"
--   PP "f" -&gt; PP "s" -&gt; String
--   </pre>
--   
--   You can always query the type, and get a well-defined type back, which
--   you can utilize using typed holes or other type-guided development
--   techniques.
--   
--   To give <a>pprintf</a> its arguments, however, they must be wrapped in
--   <a>PP</a>:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ pprintf @"You have %.2f dollars, %s" (PP 3.62) (PP "Luigi")
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   See <a>printf</a> for a polyariadic method that doesn't require
--   <a>PP</a> on its inputs, but doesn't have as usable a type when
--   queried before supplying its arguments, and <a>rprintf</a> for a
--   fake-polyariadic method that doesn't require <a>PP</a>, but requires
--   arguments in a single list instead. Also see top-level module
--   documentation <a>GHC.TypeLits.Printf</a> for a more comprehensive
--   summary.
pprintf :: forall str ps. (RPrintf str ps, RecordCurry ps) => CurriedF PP ps String

-- | A version of <a>pprintf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; :t pprintf_ (Proxy :: Proxy "You have %.2f dollars, %s")
--   PP "f" -&gt; PP "s" -&gt; String
--   </pre>
pprintf_ :: forall str ps p. (RPrintf str ps, RecordCurry ps) => p str -> CurriedF PP ps String

-- | Required wrapper around inputs to <a>pprintf</a> (guarded polyarity).
--   See documentation for <a>pprintf</a> for examples of usage.
--   
--   You can "wrap" any value in <a>PP</a> as long as it can be formatted
--   as the format type indicated.
--   
--   For example, to make a <tt><a>PP</a> "f"</tt>, you can use
--   <tt><a>PP</a> 3.5</tt> or <tt><a>PP</a> 94.2</tt>, but not
--   <tt><a>PP</a> (3 :: Int)</tt> or <tt><a>PP</a> "hello"</tt>. To make a
--   value of type <tt><a>PP</a> c</tt>, you must wrap a value that can be
--   formatted via <tt>c</tt>.
data PP (c :: SChar)
PP :: a -> PP (c :: SChar)

-- | Type-safe printf with faked polyarity. Pass in a "list" of arguments
--   (using <a>:%</a> and <a>RNil</a>), instead of as multiple arguments.
--   Call it like <tt><a>rprintf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s"
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
--   
--   This means that it is expecting something that can be printed with
--   <tt>f</tt> and something that can be printed with <tt>s</tt>. We can
--   provide a <a>Double</a> and a <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 ':%' "Luigi" :% 'RNil')
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   See <a>pprintf</a> for a version with true polyarity and good clear
--   types, but requires wrapping its arguments, and <a>printf</a> for a
--   version with true polyarity but less clear types. Also see top-level
--   module documentation <a>GHC.TypeLits.Printf</a> for a more
--   comprehensive summary.
rprintf :: forall str ps. RPrintf str ps => FormatArgs ps -> String

-- | A version of <a>rprintf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf_ (Proxy :: Proxy "You have %.2f dollars, %s")
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
rprintf_ :: RPrintf str ps => p str -> FormatArgs ps -> String

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u])
[RNil] :: forall u (a :: u -> Type). Rec a ('[] :: [u])

-- | Pattern and constructor allowing you to construct a <a>FormatArgs</a>.
--   
--   To construct a <tt><a>FormatArgs</a> '["f", "s"]</tt>, for instance,
--   you need to give a value formattable by <tt>f</tt> and a value
--   formattable by <tt>s</tt>, given like a linked list, with <a>:%</a>
--   for cons and <a>RNil</a> for nil.
--   
--   <pre>
--   3.62 <a>:%</a> <a>Luigi</a> :% <a>RNil</a>
--   </pre>
--   
--   (This should evoke the idea of of <tt>3.62 : <a>Luigi</a> : []</tt>,
--   even though the latter is not possible in Haskell)
pattern (:%) :: () => FormatChar c a => a -> FormatArgs cs -> FormatArgs (c : cs)
infixr 7 :%

-- | A heterogeneous list (from <a>Data.Vinyl.Core</a>) used for calling
--   with <a>rprintf</a>. Instead of supplying the inputs as different
--   arguments, we can gather all the inputs into a single list to give to
--   <a>rprintf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :t rprintf @"You have %.2f dollars, %s"
--   FormatArgs '["f", "s"] -&gt; String
--   </pre>
--   
--   To construct a <tt><a>FormatArgs</a> '["f", "s"]</tt>, you need to
--   give a value formattable by <tt>f</tt> and a value formattable by
--   <tt>s</tt>, given like a linked list, with <a>:%</a> for cons and
--   <a>RNil</a> for nil.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ rprintf @"You have %.2f dollars, %s" (3.62 :% "Luigi" :% RNil)
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   (This should evoke the idea of of <tt>3.62 : <a>Luigi</a> : []</tt>,
--   even though the latter is not possible in Haskell)
type FormatArgs = Rec PP

-- | Type-safe printf with true naked polyarity. Call it like
--   <tt><a>printf</a> @"you have %.02f dollars, %s"</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
--   
--   If you what the type of this function unapplied (or with not enough
--   arguments), or try to use it with typed holes or type-guided
--   development, the type errors aren't going to be pretty in most
--   situations. In addition, you always have to make sure the result type
--   can be inferred as <a>String</a>, which may require a type annotation
--   in some situations.
--   
--   (Measures have been taken to make the error messages as helpful as
--   possible, but they're not going to be as pretty as for <a>pprintf</a>
--   or <a>rprintf</a>. See <a>FormatFun</a> documentation for ways to get
--   some limited type feedback from this function.)
--   
--   Essentially, this is easier to use if you have all the right arguments
--   in place...but more difficult to debug (at compiletime) if you mess
--   up.
--   
--   Some guidelines for making sure the type-checking and debugging story
--   goes as nicely as possible:
--   
--   <ul>
--   <li>Make sure the result type is always known monomorphically.
--   Sometimes this means requiring an explicit annotation, like <tt>printf
--   ... :: String</tt>.</li>
--   <li>Make sure all the values you give to this have known monomorphic
--   types, as well.</li>
--   </ul>
--   
--   <i>However</i>, all debugging should still be only at compile-time.
--   Once it compiles, it's safe --- code with missing or badly typed
--   arguments will not compile, and so won't give you any runtime errors.
--   
--   See <a>pprintf</a> for a version of this with much nicer types and
--   type errors, but requires wrapping arguments, and <a>rprintf</a> for a
--   version of this with "fake" polyarity, taking a list as input instead.
--   Also see top-level module documentation <a>GHC.TypeLits.Printf</a> for
--   a more comprehensive summary.
printf :: forall str fun. Printf str fun => fun

-- | A version of <a>printf</a> taking an explicit proxy, which allows
--   usage without <i>TypeApplications</i>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ printf_ (Proxy :: Proxy "You have %.2f dollars, %s") 3.62 "Luigi"
--   You have 3.62 dollars, Luigi
--   </pre>
printf_ :: Printf str fun => p str -> fun

-- | The typeclass supporting polyarity used by <a>printf</a>. It works in
--   mostly the same way as <a>PrintfType</a> from <a>Text.Printf</a>, and
--   similar the same as <a>FormatF</a>.
--   
--   Ideally, you will never have to run into this typeclass or have to
--   deal with it. It will come up if you ask for the type of
--   <a>printf</a>, or if you give the wrong number or type of arguments to
--   it.
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s"
--   FormatFun '[ Right ..., 'Left " dollars ", 'Right ...] fun =&gt; fun
--   </pre>
--   
--   Every item in the first argument of <a>FormatFun</a> is a chunk of the
--   formatting string, split between format holes (<a>Right</a>) and
--   string chunks (<a>Left</a>). You can successively "eliminate" them by
--   providing more arguments that implement each hole:
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62
--   FormatFun '[ Right ...] fun =&gt; fun
--   </pre>
--   
--   Until you you finally fill all the holes:
--   
--   <pre>
--   &gt;&gt;&gt; :t printf @"You have %.2f dollars, %s" 3.62 "Luigi"
--   FormatFun '[] t =&gt; t
--   </pre>
--   
--   at which point you may use it as a <a>String</a> or <tt><a>IO</a>
--   <a>String</a></tt>, in the same way that <a>Text.Printf</a> works.
--   
--   Note that while it is somewhat possible to "reason with" or get type
--   feedback from this (as shown above), it is nowhere near the level of
--   clarity as <a>pprintf</a> or <a>rprintf</a>. And, if things go wrong
--   (like passing too many or too little arguments, or arguments of the
--   wrong type), the error messages are not going to be as useful.
--   However, there are some measures put into place to make type errors
--   more feasible for debugging, and I'm open for suggestions for
--   improvement methods, as well!
--   
--   Some guidelines for making sure the type-checking and debugging story
--   goes as nicely as possible:
--   
--   <ul>
--   <li>Make sure the result type is always known monomorphically.
--   Sometimes this means requiring an explicit annotation, like <tt>printf
--   ... :: String</tt>.</li>
--   <li>Make sure all the values you give to this have known monomorphic
--   types, as well.</li>
--   </ul>
class FormatFun (ffs :: [Either Symbol FieldFormat]) fun
